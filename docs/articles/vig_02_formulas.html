<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Implementation of formulas â€¢ regmedint</title>
<!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script><!-- Bootstrap --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/css/bootstrap.min.css" integrity="sha256-bZLfwXAP04zRMK2BjiO8iu9pf4FbLqX6zitd+tIvLhE=" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script><!-- bootstrap-toc --><link rel="stylesheet" href="../bootstrap-toc.css">
<script src="../bootstrap-toc.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><meta property="og:title" content="Implementation of formulas">
<meta property="og:description" content="regmedint">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body data-spy="scroll" data-target="#toc">
    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">regmedint</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="Released version">0.1.0</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../index.html">
    <span class="fas fa fas fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/vig_01_introduction.html">Introduction to user interface functions</a>
    </li>
    <li>
      <a href="../articles/vig_02_formulas.html">Implementation of formulas</a>
    </li>
    <li>
      <a href="../articles/vig_03_bootstrap.html">Using bootstrapping with regemedint</a>
    </li>
    <li>
      <a href="../articles/vig_04_mi.html">Using multiple imputation with regmedint</a>
    </li>
  </ul>
</li>
<li>
  <a href="../news/index.html">Changelog</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://github.com/kaz-yos/regmedint">
    <span class="fa fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      

      </header><script src="vig_02_formulas_files/header-attrs-2.1/header-attrs.js"></script><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1 data-toc-skip>Implementation of formulas</h1>
                        <h4 class="author">Kazuki Yoshida</h4>
            
            <h4 class="date">2020-05-01</h4>
      
      <small class="dont-index">Source: <a href="https://github.com/kaz-yos/regmedint/blob/master/vignettes/vig_02_formulas.Rmd"><code>vignettes/vig_02_formulas.Rmd</code></a></small>
      <div class="hidden name"><code>vig_02_formulas.Rmd</code></div>

    </div>

    
    
<p>The bodies of the following functions contain the R implementation of the formulas in V2015. Although many models are covered, there are only four patterns. See the package top page for further references. The code seen here is compacted and lacks the comments. For more redable code, please refer to the <a href="https://github.com/kaz-yos/regmedint">Github repo</a> and search for the function names without the preceding <code>regmedint:::</code>. For the type-set mathematical expressions and LaTeX source, please see the <a href="https://github.com/kaz-yos/regmedint-supplement/blob/master/supplement.pdf">supplement</a>.</p>
<div id="mreg-linear-yreg-linear-v2015-p466-proposition-2-3" class="section level1">
<h1 class="hasAnchor">
<a href="#mreg-linear-yreg-linear-v2015-p466-proposition-2-3" class="anchor"></a>mreg linear yreg linear (V2015 p466 Proposition 2.3)</h1>
<p>These functions are only used in the setting where both the mediator model and the outcome model are linear regression.</p>
<div id="point-estimates" class="section level2">
<h2 class="hasAnchor">
<a href="#point-estimates" class="anchor"></a>Point estimates</h2>
<div class="sourceCode" id="cb1"><html><body><pre class="r"><span class="kw pkg">regmedint</span><span class="kw ns">:::</span><span class="no">calc_myreg_mreg_linear_yreg_linear_est</span></pre></body></html></div>
<pre><code>## function (beta0, beta1, beta2, theta0, theta1, theta2, theta3, 
##     theta4) 
## {
##     validate_myreg_coefs(beta0 = beta0, beta1 = beta1, beta2 = beta2, 
##         theta0 = theta0, theta1 = theta1, theta2 = theta2, theta3 = theta3, 
##         theta4 = theta4)
##     fun_est &lt;- function(a0, a1, m_cde, c_cond) {
##         if (is.null(beta2)) {
##             assertthat::assert_that(is.null(c_cond))
##             beta2_c &lt;- 0
##         }
##         else {
##             assertthat::assert_that(!is.null(c_cond))
##             assertthat::assert_that(length(c_cond) == length(beta2))
##             beta2_c &lt;- sum(t(matrix(beta2)) %*% matrix(c_cond))
##         }
##         cde &lt;- (theta1 + (theta3 * m_cde)) * (a1 - a0)
##         pnde &lt;- (theta1 + (theta3 * beta0) + (theta3 * beta1 * 
##             a0) + (theta3 * beta2_c)) * (a1 - a0)
##         tnie &lt;- ((theta2 * beta1) + (theta3 * beta1 * a1)) * 
##             (a1 - a0)
##         tnde &lt;- (theta1 + (theta3 * beta0) + (theta3 * beta1 * 
##             a1) + (theta3 * beta2_c)) * (a1 - a0)
##         pnie &lt;- ((theta2 * beta1) + (theta3 * beta1 * a0)) * 
##             (a1 - a0)
##         te &lt;- pnde + tnie
##         pm &lt;- tnie/te
##         c(cde = unname(cde), pnde = unname(pnde), tnie = unname(tnie), 
##             tnde = unname(tnde), pnie = unname(pnie), te = unname(te), 
##             pm = unname(pm))
##     }
##     return(fun_est)
## }
## &lt;bytecode: 0x7fa55c9b92e0&gt;
## &lt;environment: namespace:regmedint&gt;</code></pre>
</div>
<div id="standard-error-estimates" class="section level2">
<h2 class="hasAnchor">
<a href="#standard-error-estimates" class="anchor"></a>Standard error estimates</h2>
<div class="sourceCode" id="cb3"><html><body><pre class="r"><span class="kw pkg">regmedint</span><span class="kw ns">:::</span><span class="no">calc_myreg_mreg_linear_yreg_linear_se</span></pre></body></html></div>
<pre><code>## function (beta0, beta1, beta2, theta0, theta1, theta2, theta3, 
##     theta4, Sigma_beta, Sigma_theta) 
## {
##     validate_myreg_coefs(beta0 = beta0, beta1 = beta1, beta2 = beta2, 
##         theta0 = theta0, theta1 = theta1, theta2 = theta2, theta3 = theta3, 
##         theta4 = theta4)
##     validate_myreg_vcovs(beta0 = beta0, beta1 = beta1, beta2 = beta2, 
##         theta0 = theta0, theta1 = theta1, theta2 = theta2, theta3 = theta3, 
##         theta4 = theta4, Sigma_beta = Sigma_beta, Sigma_theta = Sigma_theta)
##     Sigma &lt;- Matrix::bdiag(Sigma_beta, Sigma_theta)
##     fun_se &lt;- function(a0, a1, m_cde, c_cond) {
##         if (is.null(beta2)) {
##             assertthat::assert_that(is.null(c_cond))
##             beta2_c &lt;- 0
##         }
##         else {
##             assertthat::assert_that(!is.null(c_cond))
##             assertthat::assert_that(length(c_cond) == length(beta2))
##             beta2_c &lt;- sum(t(matrix(beta2)) %*% matrix(c_cond))
##         }
##         Gamma_cde &lt;- matrix(c(0, 0, rep(0, length(beta2)), 0, 
##             1, 0, m_cde, rep(0, length(theta4))))
##         Gamma_pnde &lt;- matrix(c(theta3, (theta3 * a0), (theta3 * 
##             c_cond), 0, 1, 0, (beta0 + (beta1 * a0) + beta2_c), 
##             rep(0, length(theta4))))
##         Gamma_tnie &lt;- matrix(c(0, (theta2 + (theta3 * a1)), rep(0, 
##             length(beta2)), 0, 0, beta1, (beta1 * a1), rep(0, 
##             length(theta4))))
##         Gamma_tnde &lt;- matrix(c(theta3, (theta3 * a1), (theta3 * 
##             c_cond), 0, 1, 0, (beta0 + (beta1 * a1) + beta2_c), 
##             rep(0, length(theta4))))
##         Gamma_pnie &lt;- matrix(c(0, (theta2 + (theta3 * a0)), rep(0, 
##             length(beta2)), 0, 0, beta1, (beta1 * a0), rep(0, 
##             length(theta4))))
##         Gamma_te &lt;- Gamma_pnde + Gamma_tnie
##         pnde &lt;- (theta1 + (theta3 * beta0) + (theta3 * beta1 * 
##             a0) + (theta3 * beta2_c)) * (a1 - a0)
##         tnie &lt;- ((theta2 * beta1) + (theta3 * beta1 * a1)) * 
##             (a1 - a0)
##         d_pm &lt;- grad_prop_med_yreg_linear(pnde = unname(pnde), 
##             tnie = unname(tnie))
##         Gamma_pm &lt;- (d_pm[["pnde"]] * Gamma_pnde) + (d_pm[["tnie"]] * 
##             Gamma_tnie)
##         a1_sub_a0 &lt;- abs(a1 - a0)
##         se_cde &lt;- sqrt(as.numeric(t(Gamma_cde) %*% Sigma %*% 
##             Gamma_cde)) * a1_sub_a0
##         se_pnde &lt;- sqrt(as.numeric(t(Gamma_pnde) %*% Sigma %*% 
##             Gamma_pnde)) * a1_sub_a0
##         se_tnie &lt;- sqrt(as.numeric(t(Gamma_tnie) %*% Sigma %*% 
##             Gamma_tnie)) * a1_sub_a0
##         se_tnde &lt;- sqrt(as.numeric(t(Gamma_tnde) %*% Sigma %*% 
##             Gamma_tnde)) * a1_sub_a0
##         se_pnie &lt;- sqrt(as.numeric(t(Gamma_pnie) %*% Sigma %*% 
##             Gamma_pnie)) * a1_sub_a0
##         se_te &lt;- sqrt(as.numeric(t(Gamma_te) %*% Sigma %*% Gamma_te)) * 
##             a1_sub_a0
##         se_pm &lt;- sqrt(as.numeric(t(Gamma_pm) %*% Sigma %*% Gamma_pm)) * 
##             a1_sub_a0
##         c(se_cde = unname(se_cde), se_pnde = unname(se_pnde), 
##             se_tnie = unname(se_tnie), se_tnde = unname(se_tnde), 
##             se_pnie = unname(se_pnie), se_te = unname(se_te), 
##             se_pm = unname(se_pm))
##     }
##     return(fun_se)
## }
## &lt;bytecode: 0x7fa55cb10ef0&gt;
## &lt;environment: namespace:regmedint&gt;</code></pre>
</div>
</div>
<div id="mreg-linear-yreg-non-linear-v2015-p468-proposition-2-4" class="section level1">
<h1 class="hasAnchor">
<a href="#mreg-linear-yreg-non-linear-v2015-p468-proposition-2-4" class="anchor"></a>mreg linear yreg non-linear (V2015 p468 Proposition 2.4)</h1>
<p>These functions are used in all cases where the mediator model is linear regression and the outcome model is any one of the non-linear models.</p>
<div id="point-estimates-1" class="section level2">
<h2 class="hasAnchor">
<a href="#point-estimates-1" class="anchor"></a>Point estimates</h2>
<div class="sourceCode" id="cb5"><html><body><pre class="r"><span class="kw pkg">regmedint</span><span class="kw ns">:::</span><span class="no">calc_myreg_mreg_linear_yreg_logistic_est</span></pre></body></html></div>
<pre><code>## function (beta0, beta1, beta2, theta0, theta1, theta2, theta3, 
##     theta4, sigma_sq) 
## {
##     validate_myreg_coefs(beta0 = beta0, beta1 = beta1, beta2 = beta2, 
##         theta0 = theta0, theta1 = theta1, theta2 = theta2, theta3 = theta3, 
##         theta4 = theta4, sigma_sq = sigma_sq)
##     fun_est &lt;- function(a0, a1, m_cde, c_cond) {
##         if (is.null(beta2)) {
##             assertthat::assert_that(is.null(c_cond))
##             beta2_c &lt;- 0
##         }
##         else {
##             assertthat::assert_that(!is.null(c_cond))
##             assertthat::assert_that(length(c_cond) == length(beta2))
##             beta2_c &lt;- sum(t(matrix(beta2)) %*% matrix(c_cond))
##         }
##         cde &lt;- (theta1 + (theta3 * m_cde)) * (a1 - a0)
##         pnde &lt;- (theta1 + (theta3 * beta0) + (theta3 * beta1 * 
##             a0) + (theta3 * beta2_c) + (theta3 * theta2 * sigma_sq)) * 
##             (a1 - a0) + ((1/2) * theta3^2 * sigma_sq) * (a1^2 - 
##             a0^2)
##         tnie &lt;- ((theta2 * beta1) + theta3 * beta1 * a1) * (a1 - 
##             a0)
##         tnde &lt;- (theta1 + (theta3 * beta0) + (theta3 * beta1 * 
##             a1) + (theta3 * beta2_c) + (theta3 * theta2 * sigma_sq)) * 
##             (a1 - a0) + ((1/2) * theta3^2 * sigma_sq) * (a1^2 - 
##             a0^2)
##         pnie &lt;- ((theta2 * beta1) + theta3 * beta1 * a0) * (a1 - 
##             a0)
##         te &lt;- pnde + tnie
##         pm &lt;- (exp(pnde) * (exp(tnie) - 1))/(exp(te) - 1)
##         c(cde = unname(cde), pnde = unname(pnde), tnie = unname(tnie), 
##             tnde = unname(tnde), pnie = unname(pnie), te = unname(te), 
##             pm = unname(pm))
##     }
##     return(fun_est)
## }
## &lt;bytecode: 0x7fa55b386070&gt;
## &lt;environment: namespace:regmedint&gt;</code></pre>
</div>
<div id="standard-error-estimates-1" class="section level2">
<h2 class="hasAnchor">
<a href="#standard-error-estimates-1" class="anchor"></a>Standard error estimates</h2>
<div class="sourceCode" id="cb7"><html><body><pre class="r"><span class="kw pkg">regmedint</span><span class="kw ns">:::</span><span class="no">calc_myreg_mreg_linear_yreg_logistic_se</span></pre></body></html></div>
<pre><code>## function (beta0, beta1, beta2, theta0, theta1, theta2, theta3, 
##     theta4, sigma_sq, Sigma_beta, Sigma_theta, Sigma_sigma_sq) 
## {
##     validate_myreg_coefs(beta0 = beta0, beta1 = beta1, beta2 = beta2, 
##         theta0 = theta0, theta1 = theta1, theta2 = theta2, theta3 = theta3, 
##         theta4 = theta4, sigma_sq = sigma_sq)
##     validate_myreg_vcovs(beta0 = beta0, beta1 = beta1, beta2 = beta2, 
##         theta0 = theta0, theta1 = theta1, theta2 = theta2, theta3 = theta3, 
##         theta4 = theta4, sigma_sq = sigma_sq, Sigma_beta = Sigma_beta, 
##         Sigma_theta = Sigma_theta, Sigma_sigma_sq = Sigma_sigma_sq)
##     Sigma &lt;- Matrix::bdiag(Sigma_beta, Sigma_theta, Sigma_sigma_sq)
##     fun_se &lt;- function(a0, a1, m_cde, c_cond) {
##         if (is.null(beta2)) {
##             assertthat::assert_that(is.null(c_cond))
##             beta2_c &lt;- 0
##         }
##         else {
##             assertthat::assert_that(!is.null(c_cond))
##             assertthat::assert_that(length(c_cond) == length(beta2))
##             beta2_c &lt;- sum(t(matrix(beta2)) %*% matrix(c_cond))
##         }
##         Gamma_cde &lt;- matrix(c(0, 0, rep(0, length(beta2)), 0, 
##             1, 0, m_cde, rep(0, length(theta4)), 0))
##         Gamma_pnde &lt;- matrix(c(theta3, (theta3 * a0), (theta3 * 
##             c_cond), 0, 1, (theta3 * sigma_sq), (beta0 + beta1 * 
##             a0 + beta2_c + theta2 * sigma_sq + theta3 * sigma_sq * 
##             (a1 + a0)), rep(0, length(theta4)), (theta3 * theta2 + 
##             (1/2) * theta3^2 * (a1 + a0))))
##         Gamma_tnie &lt;- matrix(c(0, (theta2 + theta3 * a1), rep(0, 
##             length(beta2)), 0, 0, beta1, (beta1 * a1), rep(0, 
##             length(theta4)), 0))
##         Gamma_tnde &lt;- matrix(c(theta3, (theta3 * a1), (theta3 * 
##             c_cond), 0, 1, (theta3 * sigma_sq), (beta0 + beta1 * 
##             a1 + beta2_c + theta2 * sigma_sq + theta3 * sigma_sq * 
##             (a1 + a0)), rep(0, length(theta4)), (theta3 * theta2 + 
##             (1/2) * theta3^2 * (a1 + a0))))
##         Gamma_pnie &lt;- matrix(c(0, (theta2 + theta3 * a0), rep(0, 
##             length(beta2)), 0, 0, beta1, (beta1 * a0), rep(0, 
##             length(theta4)), 0))
##         Gamma_te &lt;- Gamma_pnde + Gamma_tnie
##         pnde &lt;- (theta1 + (theta3 * beta0) + (theta3 * beta1 * 
##             a0) + (theta3 * beta2_c) + (theta3 * theta2 * sigma_sq)) * 
##             (a1 - a0) + ((1/2) * theta3^2 * sigma_sq) * (a1^2 - 
##             a0^2)
##         tnie &lt;- ((theta2 * beta1) + theta3 * beta1 * a1) * (a1 - 
##             a0)
##         d_pm &lt;- grad_prop_med_yreg_logistic(pnde = unname(pnde), 
##             tnie = unname(tnie))
##         Gamma_pm &lt;- d_pm[["pnde"]] * Gamma_pnde + d_pm[["tnie"]] * 
##             Gamma_tnie
##         a1_sub_a0 &lt;- abs(a1 - a0)
##         se_cde &lt;- sqrt(as.numeric(t(Gamma_cde) %*% Sigma %*% 
##             Gamma_cde)) * a1_sub_a0
##         se_pnde &lt;- sqrt(as.numeric(t(Gamma_pnde) %*% Sigma %*% 
##             Gamma_pnde)) * a1_sub_a0
##         se_tnie &lt;- sqrt(as.numeric(t(Gamma_tnie) %*% Sigma %*% 
##             Gamma_tnie)) * a1_sub_a0
##         se_tnde &lt;- sqrt(as.numeric(t(Gamma_tnde) %*% Sigma %*% 
##             Gamma_tnde)) * a1_sub_a0
##         se_pnie &lt;- sqrt(as.numeric(t(Gamma_pnie) %*% Sigma %*% 
##             Gamma_pnie)) * a1_sub_a0
##         se_te &lt;- sqrt(as.numeric(t(Gamma_te) %*% Sigma %*% Gamma_te)) * 
##             a1_sub_a0
##         se_pm &lt;- sqrt(as.numeric(t(Gamma_pm) %*% Sigma %*% Gamma_pm)) * 
##             a1_sub_a0
##         c(se_cde = unname(se_cde), se_pnde = unname(se_pnde), 
##             se_tnie = unname(se_tnie), se_tnde = unname(se_tnde), 
##             se_pnie = unname(se_pnie), se_te = unname(se_te), 
##             se_pm = unname(se_pm))
##     }
##     return(fun_se)
## }
## &lt;bytecode: 0x7fa55d0a5430&gt;
## &lt;environment: namespace:regmedint&gt;</code></pre>
</div>
</div>
<div id="mreg-logistic-yreg-linear-v2015-p471-proposition-2-5" class="section level1">
<h1 class="hasAnchor">
<a href="#mreg-logistic-yreg-linear-v2015-p471-proposition-2-5" class="anchor"></a>mreg logistic yreg linear (V2015 p471 Proposition 2.5)</h1>
<p>These functions are only used in the setting where the mediator model is logistic regression and the outcome model is non-linear regression.</p>
<div id="point-estimates-2" class="section level2">
<h2 class="hasAnchor">
<a href="#point-estimates-2" class="anchor"></a>Point estimates</h2>
<div class="sourceCode" id="cb9"><html><body><pre class="r"><span class="kw pkg">regmedint</span><span class="kw ns">:::</span><span class="no">calc_myreg_mreg_logistic_yreg_linear_est</span></pre></body></html></div>
<pre><code>## function (beta0, beta1, beta2, theta0, theta1, theta2, theta3, 
##     theta4) 
## {
##     validate_myreg_coefs(beta0 = beta0, beta1 = beta1, beta2 = beta2, 
##         theta0 = theta0, theta1 = theta1, theta2 = theta2, theta3 = theta3, 
##         theta4 = theta4)
##     fun_est &lt;- function(a0, a1, m_cde, c_cond) {
##         if (is.null(beta2)) {
##             assertthat::assert_that(is.null(c_cond))
##             beta2_c &lt;- 0
##         }
##         else {
##             assertthat::assert_that(!is.null(c_cond))
##             assertthat::assert_that(length(c_cond) == length(beta2))
##             beta2_c &lt;- sum(t(matrix(beta2)) %*% matrix(c_cond))
##         }
##         cde &lt;- (theta1 + (theta3 * m_cde)) * (a1 - a0)
##         pnde &lt;- (theta1 * (a1 - a0)) + (theta3 * (a1 - a0)) * 
##             (exp(beta0 + (beta1 * a0) + beta2_c)/(1 + exp(beta0 + 
##                 (beta1 * a0) + beta2_c)))
##         tnie &lt;- (theta2 + (theta3 * a1)) * ((exp(beta0 + (beta1 * 
##             a1) + beta2_c)/(1 + exp(beta0 + (beta1 * a1) + beta2_c))) - 
##             (exp(beta0 + (beta1 * a0) + beta2_c)/(1 + exp(beta0 + 
##                 (beta1 * a0) + beta2_c))))
##         tnde &lt;- (theta1 * (a1 - a0)) + (theta3 * (a1 - a0)) * 
##             (exp(beta0 + (beta1 * a1) + beta2_c)/(1 + exp(beta0 + 
##                 (beta1 * a1) + beta2_c)))
##         pnie &lt;- (theta2 + (theta3 * a0)) * ((exp(beta0 + (beta1 * 
##             a1) + beta2_c)/(1 + exp(beta0 + (beta1 * a1) + beta2_c))) - 
##             (exp(beta0 + (beta1 * a0) + beta2_c)/(1 + exp(beta0 + 
##                 (beta1 * a0) + beta2_c))))
##         te &lt;- pnde + tnie
##         pm &lt;- tnie/te
##         c(cde = unname(cde), pnde = unname(pnde), tnie = unname(tnie), 
##             tnde = unname(tnde), pnie = unname(pnie), te = unname(te), 
##             pm = unname(pm))
##     }
##     return(fun_est)
## }
## &lt;bytecode: 0x7fa55d1f8d68&gt;
## &lt;environment: namespace:regmedint&gt;</code></pre>
</div>
<div id="standard-error-estimates-2" class="section level2">
<h2 class="hasAnchor">
<a href="#standard-error-estimates-2" class="anchor"></a>Standard error estimates</h2>
<div class="sourceCode" id="cb11"><html><body><pre class="r"><span class="kw pkg">regmedint</span><span class="kw ns">:::</span><span class="no">calc_myreg_mreg_logistic_yreg_linear_se</span></pre></body></html></div>
<pre><code>## function (beta0, beta1, beta2, theta0, theta1, theta2, theta3, 
##     theta4, Sigma_beta, Sigma_theta) 
## {
##     validate_myreg_coefs(beta0 = beta0, beta1 = beta1, beta2 = beta2, 
##         theta0 = theta0, theta1 = theta1, theta2 = theta2, theta3 = theta3, 
##         theta4 = theta4)
##     validate_myreg_vcovs(beta0 = beta0, beta1 = beta1, beta2 = beta2, 
##         theta0 = theta0, theta1 = theta1, theta2 = theta2, theta3 = theta3, 
##         theta4 = theta4, Sigma_beta = Sigma_beta, Sigma_theta = Sigma_theta)
##     Sigma &lt;- Matrix::bdiag(Sigma_beta, Sigma_theta)
##     fun_se &lt;- function(a0, a1, m_cde, c_cond) {
##         if (is.null(beta2)) {
##             assertthat::assert_that(is.null(c_cond))
##             beta2_c &lt;- 0
##         }
##         else {
##             assertthat::assert_that(!is.null(c_cond))
##             assertthat::assert_that(length(c_cond) == length(beta2))
##             beta2_c &lt;- sum(t(matrix(beta2)) %*% matrix(c_cond))
##         }
##         Gamma_cde &lt;- matrix(c(0, 0, rep(0, length(beta2)), 0, 
##             1, 0, m_cde, rep(0, length(theta4))))
##         pnde_d1 &lt;- theta3 * (exp(beta0 + (beta1 * a0) + beta2_c)/(1 + 
##             exp(beta0 + (beta1 * a0) + beta2_c))^2)
##         pnde_d2 &lt;- a0 * pnde_d1
##         pnde_d3 &lt;- c_cond * pnde_d1
##         pnde_d4 &lt;- 0
##         pnde_d5 &lt;- 1
##         pnde_d6 &lt;- 0
##         pnde_d7 &lt;- exp(beta0 + (beta1 * a0) + beta2_c)/(1 + exp(beta0 + 
##             (beta1 * a0) + beta2_c))
##         pnde_d8 &lt;- rep(0, length(theta4))
##         Gamma_pnde &lt;- matrix(c(pnde_d1, pnde_d2, pnde_d3, pnde_d4, 
##             pnde_d5, pnde_d6, pnde_d7, pnde_d8))
##         tnie_Q &lt;- exp(beta0 + (beta1 * a1) + beta2_c)/(1 + exp(beta0 + 
##             (beta1 * a1) + beta2_c))^2
##         tnie_B &lt;- exp(beta0 + (beta1 * a0) + beta2_c)/(1 + exp(beta0 + 
##             (beta1 * a0) + beta2_c))^2
##         tnie_K &lt;- exp(beta0 + (beta1 * a1) + beta2_c)/(1 + exp(beta0 + 
##             (beta1 * a1) + beta2_c))
##         tnie_D &lt;- exp(beta0 + (beta1 * a0) + beta2_c)/(1 + exp(beta0 + 
##             (beta1 * a0) + beta2_c))
##         tnie_d1 &lt;- (theta2 + (theta3 * a1)) * (tnie_Q - tnie_B)
##         tnie_d2 &lt;- (theta2 + (theta3 * a1)) * ((a1 * tnie_Q) - 
##             (a0 * tnie_B))
##         tnie_d3 &lt;- (theta2 + (theta3 * a1)) * c_cond * (tnie_Q - 
##             tnie_B)
##         tnie_d4 &lt;- 0
##         tnie_d5 &lt;- 0
##         tnie_d6 &lt;- tnie_K - tnie_D
##         tnie_d7 &lt;- a1 * (tnie_K - tnie_D)
##         tnie_d8 &lt;- rep(0, length(theta4))
##         Gamma_tnie &lt;- matrix(c(tnie_d1, tnie_d2, tnie_d3, tnie_d4, 
##             tnie_d5, tnie_d6, tnie_d7, tnie_d8))
##         tnde_d1 &lt;- theta3 * (exp(beta0 + (beta1 * a1) + beta2_c)/(1 + 
##             exp(beta0 + (beta1 * a1) + beta2_c))^2)
##         tnde_d2 &lt;- a1 * tnde_d1
##         tnde_d3 &lt;- c_cond * tnde_d1
##         tnde_d4 &lt;- 0
##         tnde_d5 &lt;- 1
##         tnde_d6 &lt;- 0
##         tnde_d7 &lt;- exp(beta0 + (beta1 * a1) + beta2_c)/(1 + exp(beta0 + 
##             (beta1 * a1) + beta2_c))
##         tnde_d8 &lt;- rep(0, length(theta4))
##         Gamma_tnde &lt;- matrix(c(tnde_d1, tnde_d2, tnde_d3, tnde_d4, 
##             tnde_d5, tnde_d6, tnde_d7, tnde_d8))
##         pnie_Q &lt;- exp(beta0 + (beta1 * a1) + beta2_c)/(1 + exp(beta0 + 
##             (beta1 * a1) + beta2_c))^2
##         pnie_B &lt;- exp(beta0 + (beta1 * a0) + beta2_c)/(1 + exp(beta0 + 
##             (beta1 * a0) + beta2_c))^2
##         pnie_K &lt;- exp(beta0 + (beta1 * a1) + beta2_c)/(1 + exp(beta0 + 
##             (beta1 * a1) + beta2_c))
##         pnie_D &lt;- exp(beta0 + (beta1 * a0) + beta2_c)/(1 + exp(beta0 + 
##             (beta1 * a0) + beta2_c))
##         pnie_d1 &lt;- (theta2 + (theta3 * a0)) * (pnie_Q - pnie_B)
##         pnie_d2 &lt;- (theta2 + (theta3 * a0)) * ((a1 * pnie_Q) - 
##             (a0 * pnie_B))
##         pnie_d3 &lt;- (theta2 + (theta3 * a0)) * c_cond * (pnie_Q - 
##             pnie_B)
##         pnie_d4 &lt;- 0
##         pnie_d5 &lt;- 0
##         pnie_d6 &lt;- pnie_K - pnie_D
##         pnie_d7 &lt;- a0 * (pnie_K - pnie_D)
##         pnie_d8 &lt;- rep(0, length(theta4))
##         Gamma_pnie &lt;- matrix(c(pnie_d1, pnie_d2, pnie_d3, pnie_d4, 
##             pnie_d5, pnie_d6, pnie_d7, pnie_d8))
##         Gamma_te &lt;- ((a1 - a0) * Gamma_pnde) + Gamma_tnie
##         pnde &lt;- (theta1 * (a1 - a0)) + (theta3 * (a1 - a0)) * 
##             (exp(beta0 + (beta1 * a0) + beta2_c)/(1 + exp(beta0 + 
##                 (beta1 * a0) + beta2_c)))
##         tnie &lt;- (theta2 + (theta3 * a1)) * ((exp(beta0 + (beta1 * 
##             a1) + beta2_c)/(1 + exp(beta0 + (beta1 * a1) + beta2_c))) - 
##             (exp(beta0 + (beta1 * a0) + beta2_c)/(1 + exp(beta0 + 
##                 (beta1 * a0) + beta2_c))))
##         d_pm &lt;- grad_prop_med_yreg_linear(pnde = unname(pnde), 
##             tnie = unname(tnie))
##         Gamma_pm &lt;- (d_pm[["pnde"]] * (a1 - a0) * Gamma_pnde) + 
##             (d_pm[["tnie"]] * Gamma_tnie)
##         a1_sub_a0 &lt;- abs(a1 - a0)
##         se_cde &lt;- sqrt(as.numeric(t(Gamma_cde) %*% Sigma %*% 
##             Gamma_cde)) * a1_sub_a0
##         se_pnde &lt;- sqrt(as.numeric(t(Gamma_pnde) %*% Sigma %*% 
##             Gamma_pnde)) * a1_sub_a0
##         se_tnie &lt;- sqrt(as.numeric(t(Gamma_tnie) %*% Sigma %*% 
##             Gamma_tnie))
##         se_tnde &lt;- sqrt(as.numeric(t(Gamma_tnde) %*% Sigma %*% 
##             Gamma_tnde)) * a1_sub_a0
##         se_pnie &lt;- sqrt(as.numeric(t(Gamma_pnie) %*% Sigma %*% 
##             Gamma_pnie))
##         se_te &lt;- sqrt(as.numeric(t(Gamma_te) %*% Sigma %*% Gamma_te))
##         se_pm &lt;- sqrt(as.numeric(t(Gamma_pm) %*% Sigma %*% Gamma_pm))
##         c(se_cde = unname(se_cde), se_pnde = unname(se_pnde), 
##             se_tnie = unname(se_tnie), se_tnde = unname(se_tnde), 
##             se_pnie = unname(se_pnie), se_te = unname(se_te), 
##             se_pm = unname(se_pm))
##     }
##     return(fun_se)
## }
## &lt;bytecode: 0x7fa55d34a0e0&gt;
## &lt;environment: namespace:regmedint&gt;</code></pre>
</div>
</div>
<div id="mreg-logistic-yreg-non-linear-v2015-p473-proposition-2-6" class="section level1">
<h1 class="hasAnchor">
<a href="#mreg-logistic-yreg-non-linear-v2015-p473-proposition-2-6" class="anchor"></a>mreg logistic yreg non-linear (V2015 p473 Proposition 2.6)</h1>
<p>These functions are used in all cases where the mediator model is logistic regression and the outcome model is any one of the non-linear models.</p>
<div id="point-estimates-3" class="section level2">
<h2 class="hasAnchor">
<a href="#point-estimates-3" class="anchor"></a>Point estimates</h2>
<div class="sourceCode" id="cb13"><html><body><pre class="r"><span class="kw pkg">regmedint</span><span class="kw ns">:::</span><span class="no">calc_myreg_mreg_logistic_yreg_logistic_est</span></pre></body></html></div>
<pre><code>## function (beta0, beta1, beta2, theta0, theta1, theta2, theta3, 
##     theta4) 
## {
##     validate_myreg_coefs(beta0 = beta0, beta1 = beta1, beta2 = beta2, 
##         theta0 = theta0, theta1 = theta1, theta2 = theta2, theta3 = theta3, 
##         theta4 = theta4)
##     fun_est &lt;- function(a0, a1, m_cde, c_cond) {
##         if (is.null(beta2)) {
##             assertthat::assert_that(is.null(c_cond))
##             beta2_c &lt;- 0
##         }
##         else {
##             assertthat::assert_that(!is.null(c_cond))
##             assertthat::assert_that(length(c_cond) == length(beta2))
##             beta2_c &lt;- sum(t(matrix(beta2)) %*% matrix(c_cond))
##         }
##         cde &lt;- (theta1 + (theta3 * m_cde)) * (a1 - a0)
##         pnde &lt;- (theta1 * (a1 - a0)) + log(1 + exp(theta2 + (theta3 * 
##             a1) + beta0 + (beta1 * a0) + beta2_c)) - log(1 + 
##             exp(theta2 + (theta3 * a0) + beta0 + (beta1 * a0) + 
##                 beta2_c))
##         tnie &lt;- log(1 + exp(beta0 + (beta1 * a0) + beta2_c)) - 
##             log(1 + exp(beta0 + (beta1 * a1) + beta2_c)) + log(1 + 
##             exp(theta2 + (theta3 * a1) + beta0 + (beta1 * a1) + 
##                 beta2_c)) - log(1 + exp(theta2 + (theta3 * a1) + 
##             beta0 + (beta1 * a0) + beta2_c))
##         tnde &lt;- (theta1 * (a1 - a0)) + log(1 + exp(theta2 + (theta3 * 
##             a1) + beta0 + (beta1 * a1) + beta2_c)) - log(1 + 
##             exp(theta2 + (theta3 * a0) + beta0 + (beta1 * a1) + 
##                 beta2_c))
##         pnie &lt;- log(1 + exp(beta0 + (beta1 * a0) + beta2_c)) - 
##             log(1 + exp(beta0 + (beta1 * a1) + beta2_c)) + log(1 + 
##             exp(theta2 + (theta3 * a0) + beta0 + (beta1 * a1) + 
##                 beta2_c)) - log(1 + exp(theta2 + (theta3 * a0) + 
##             beta0 + (beta1 * a0) + beta2_c))
##         te &lt;- pnde + tnie
##         pm &lt;- (exp(pnde) * (exp(tnie) - 1))/(exp(te) - 1)
##         c(cde = unname(cde), pnde = unname(pnde), tnie = unname(tnie), 
##             tnde = unname(tnde), pnie = unname(pnie), te = unname(te), 
##             pm = unname(pm))
##     }
##     return(fun_est)
## }
## &lt;bytecode: 0x7fa55d4b2dd8&gt;
## &lt;environment: namespace:regmedint&gt;</code></pre>
</div>
<div id="standard-error-estimates-3" class="section level2">
<h2 class="hasAnchor">
<a href="#standard-error-estimates-3" class="anchor"></a>Standard error estimates</h2>
<div class="sourceCode" id="cb15"><html><body><pre class="r"><span class="kw pkg">regmedint</span><span class="kw ns">:::</span><span class="no">calc_myreg_mreg_logistic_yreg_logistic_se</span></pre></body></html></div>
<pre><code>## function (beta0, beta1, beta2, theta0, theta1, theta2, theta3, 
##     theta4, Sigma_beta, Sigma_theta) 
## {
##     validate_myreg_coefs(beta0 = beta0, beta1 = beta1, beta2 = beta2, 
##         theta0 = theta0, theta1 = theta1, theta2 = theta2, theta3 = theta3, 
##         theta4 = theta4)
##     validate_myreg_vcovs(beta0 = beta0, beta1 = beta1, beta2 = beta2, 
##         theta0 = theta0, theta1 = theta1, theta2 = theta2, theta3 = theta3, 
##         theta4 = theta4, Sigma_beta = Sigma_beta, Sigma_theta = Sigma_theta)
##     Sigma &lt;- Matrix::bdiag(Sigma_beta, Sigma_theta)
##     fun_se &lt;- function(a0, a1, m_cde, c_cond) {
##         if (is.null(beta2)) {
##             assertthat::assert_that(is.null(c_cond))
##             beta2_c &lt;- 0
##         }
##         else {
##             assertthat::assert_that(!is.null(c_cond))
##             assertthat::assert_that(length(c_cond) == length(beta2))
##             beta2_c &lt;- sum(t(matrix(beta2)) %*% matrix(c_cond))
##         }
##         Gamma_cde &lt;- matrix(c(0, 0, rep(0, length(beta2)), 0, 
##             (a1 - a0), 0, (a1 - a0) * m_cde, rep(0, length(theta4))))
##         pnde_Q &lt;- exp(theta2 + (theta3 * a1) + beta0 + (beta1 * 
##             a0) + beta2_c)/(1 + exp(theta2 + (theta3 * a1) + 
##             beta0 + (beta1 * a0) + beta2_c))
##         pnde_B &lt;- exp(theta2 + (theta3 * a0) + beta0 + (beta1 * 
##             a0) + beta2_c)/(1 + exp(theta2 + (theta3 * a0) + 
##             beta0 + (beta1 * a0) + beta2_c))
##         pnde_d1 &lt;- pnde_Q - pnde_B
##         pnde_d2 &lt;- a0 * pnde_d1
##         pnde_d3 &lt;- c_cond * pnde_d1
##         pnde_d4 &lt;- 0
##         pnde_d5 &lt;- (a1 - a0)
##         pnde_d6 &lt;- pnde_Q - pnde_B
##         pnde_d7 &lt;- (a1 * pnde_Q) - (a0 * pnde_B)
##         pnde_d8 &lt;- rep(0, length(theta4))
##         Gamma_pnde &lt;- matrix(c(pnde_d1, pnde_d2, pnde_d3, pnde_d4, 
##             pnde_d5, pnde_d6, pnde_d7, pnde_d8))
##         tnie_Q &lt;- exp(theta2 + (theta3 * a1) + beta0 + (beta1 * 
##             a1) + beta2_c)/(1 + exp(theta2 + (theta3 * a1) + 
##             beta0 + (beta1 * a1) + beta2_c))
##         tnie_B &lt;- exp(theta2 + (theta3 * a1) + beta0 + (beta1 * 
##             a0) + beta2_c)/(1 + exp(theta2 + (theta3 * a1) + 
##             beta0 + (beta1 * a0) + beta2_c))
##         tnie_K &lt;- exp(beta0 + (beta1 * a1) + beta2_c)/(1 + exp(beta0 + 
##             (beta1 * a1) + beta2_c))
##         tnie_D &lt;- exp(beta0 + (beta1 * a0) + beta2_c)/(1 + exp(beta0 + 
##             (beta1 * a0) + beta2_c))
##         tnie_d1 &lt;- (tnie_D + tnie_Q) - (tnie_K + tnie_B)
##         tnie_d2 &lt;- (a0 * (tnie_D - tnie_B)) + (a1 * (tnie_Q - 
##             tnie_K))
##         tnie_d3 &lt;- c_cond * ((tnie_D + tnie_Q) - (tnie_K + tnie_B))
##         tnie_d4 &lt;- 0
##         tnie_d5 &lt;- 0
##         tnie_d6 &lt;- tnie_Q - tnie_B
##         tnie_d7 &lt;- a1 * (tnie_Q - tnie_B)
##         tnie_d8 &lt;- rep(0, length(theta4))
##         Gamma_tnie &lt;- matrix(c(tnie_d1, tnie_d2, tnie_d3, tnie_d4, 
##             tnie_d5, tnie_d6, tnie_d7, tnie_d8))
##         tnde_Q &lt;- exp(theta2 + (theta3 * a1) + beta0 + (beta1 * 
##             a1) + beta2_c)/(1 + exp(theta2 + (theta3 * a1) + 
##             beta0 + (beta1 * a1) + beta2_c))
##         tnde_B &lt;- exp(theta2 + (theta3 * a0) + beta0 + (beta1 * 
##             a1) + beta2_c)/(1 + exp(theta2 + (theta3 * a0) + 
##             beta0 + (beta1 * a1) + beta2_c))
##         tnde_d1 &lt;- tnde_Q - tnde_B
##         tnde_d2 &lt;- a1 * tnde_d1
##         tnde_d3 &lt;- c_cond * tnde_d1
##         tnde_d4 &lt;- 0
##         tnde_d5 &lt;- (a1 - a0)
##         tnde_d6 &lt;- tnde_Q - tnde_B
##         tnde_d7 &lt;- (a1 * tnde_Q) - (a0 * tnde_B)
##         tnde_d8 &lt;- rep(0, length(theta4))
##         Gamma_tnde &lt;- matrix(c(tnde_d1, tnde_d2, tnde_d3, tnde_d4, 
##             tnde_d5, tnde_d6, tnde_d7, tnde_d8))
##         pnie_Q &lt;- exp(theta2 + (theta3 * a0) + beta0 + (beta1 * 
##             a1) + beta2_c)/(1 + exp(theta2 + (theta3 * a0) + 
##             beta0 + (beta1 * a1) + beta2_c))
##         pnie_B &lt;- exp(theta2 + (theta3 * a0) + beta0 + (beta1 * 
##             a0) + beta2_c)/(1 + exp(theta2 + (theta3 * a0) + 
##             beta0 + (beta1 * a0) + beta2_c))
##         pnie_K &lt;- exp(beta0 + (beta1 * a1) + beta2_c)/(1 + exp(beta0 + 
##             (beta1 * a1) + beta2_c))
##         pnie_D &lt;- exp(beta0 + (beta1 * a0) + beta2_c)/(1 + exp(beta0 + 
##             (beta1 * a0) + beta2_c))
##         pnie_d1 &lt;- (pnie_D + pnie_Q) - (pnie_K + pnie_B)
##         pnie_d2 &lt;- (a0 * (pnie_D - pnie_B)) + (a1 * (pnie_Q - 
##             pnie_K))
##         pnie_d3 &lt;- c_cond * ((pnie_D + pnie_Q) - (pnie_K + pnie_B))
##         pnie_d4 &lt;- 0
##         pnie_d5 &lt;- 0
##         pnie_d6 &lt;- pnie_Q - pnie_B
##         pnie_d7 &lt;- a0 * (pnie_Q - pnie_B)
##         pnie_d8 &lt;- rep(0, length(theta4))
##         Gamma_pnie &lt;- matrix(c(pnie_d1, pnie_d2, pnie_d3, pnie_d4, 
##             pnie_d5, pnie_d6, pnie_d7, pnie_d8))
##         Gamma_te &lt;- Gamma_pnde + Gamma_tnie
##         pnde &lt;- (exp(theta1 * a1) * (1 + exp(theta2 + (theta3 * 
##             a1) + beta0 + (beta1 * a0) + beta2_c)))/(exp(theta1 * 
##             a0) * (1 + exp(theta2 + (theta3 * a0) + beta0 + (beta1 * 
##             a0) + beta2_c)))
##         tnie &lt;- ((1 + exp(beta0 + (beta1 * a0) + beta2_c)) * 
##             (1 + exp(theta2 + (theta3 * a1) + beta0 + (beta1 * 
##                 a1) + beta2_c)))/((1 + exp(beta0 + (beta1 * a1) + 
##             beta2_c)) * (1 + exp(theta2 + (theta3 * a1) + beta0 + 
##             (beta1 * a0) + beta2_c)))
##         d_pm &lt;- grad_prop_med_yreg_logistic(pnde = unname(pnde), 
##             tnie = unname(tnie))
##         Gamma_pm &lt;- (d_pm[["pnde"]] * Gamma_pnde) + (d_pm[["tnie"]] * 
##             Gamma_tnie)
##         se_cde &lt;- sqrt(as.numeric(t(Gamma_cde) %*% Sigma %*% 
##             Gamma_cde))
##         se_pnde &lt;- sqrt(as.numeric(t(Gamma_pnde) %*% Sigma %*% 
##             Gamma_pnde))
##         se_tnie &lt;- sqrt(as.numeric(t(Gamma_tnie) %*% Sigma %*% 
##             Gamma_tnie))
##         se_tnde &lt;- sqrt(as.numeric(t(Gamma_tnde) %*% Sigma %*% 
##             Gamma_tnde))
##         se_pnie &lt;- sqrt(as.numeric(t(Gamma_pnie) %*% Sigma %*% 
##             Gamma_pnie))
##         se_te &lt;- sqrt(as.numeric(t(Gamma_te) %*% Sigma %*% Gamma_te))
##         se_pm &lt;- sqrt(as.numeric(t(Gamma_pm) %*% Sigma %*% Gamma_pm))
##         c(se_cde = unname(se_cde), se_pnde = unname(se_pnde), 
##             se_tnie = unname(se_tnie), se_tnde = unname(se_tnde), 
##             se_pnie = unname(se_pnie), se_te = unname(se_te), 
##             se_pm = unname(se_pm))
##     }
##     return(fun_se)
## }
## &lt;bytecode: 0x7fa55d6020e0&gt;
## &lt;environment: namespace:regmedint&gt;</code></pre>
</div>
</div>
<div id="bibliography" class="section level1">
<h1 class="hasAnchor">
<a href="#bibliography" class="anchor"></a>Bibliography</h1>
<ul>
<li>V2015: VanderWeele (2015) Explanation in Causal Inference</li>
</ul>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">

        <nav id="toc" data-toggle="toc"><h2 data-toc-skip>Contents</h2>
    </nav>
</div>

</div>



      <footer><div class="copyright">
  <p>Developed by Kazuki Yoshida.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="https://pkgdown.r-lib.org/">pkgdown</a> 1.5.1.</p>
</div>

      </footer>
</div>

  


  </body>
</html>
